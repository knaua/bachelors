#[macro_use] extern crate rocket;

mod booking_process;
mod db_manager;

use rocket::serde::Deserialize;
use rocket::serde::json::Json;
use rocket_db_pools::{Connection, Database};
use rocket_dyn_templates::{Template, context};
use crate::booking_process::{end_booking, start_booking, connect_device_to_interface};
use crate::db_manager::{add_interface_to_db, add_device_to_db, Db};


/// Struct for the parameters of a booking request
// TODO Minutes for the booking duration are currently not used as the system is lacking an automated way to end a reservation which would utilize this field
#[derive(Deserialize)]
pub struct BookingData {
    devices: u8,
    _minutes: i32,
    team_name: String,
    public_key: String,
}

/// Struct for adding devices to the database
#[derive(Deserialize)]
pub struct DeviceData{
    mac_address: String,
    interface_id: String,
}

/// Struct for adding devices to a running WireGuard interface
#[derive(Deserialize)]
pub struct DeviceInterfaceData {
    public_key: String,
    wg_ip_address: String,
    interface_id: String,
}

/// Struct used for adding a WireGuard interface to the database and fetch the relevant information to set up a connection to this interface
#[derive(Deserialize)]
pub struct InterfaceData{
    interface_id: String,
    ip_address: String,
    port: String,
    host_public_key: String,
    available: bool,
}

/// Struct used to retrieve the necessary data of a peer connected to a WireGuard interface to remove that peer from it
#[derive(Deserialize)]
pub struct ConnectedPeer {
    interface_id: String,
    public_key: String,
}

/// Struct used for manually ending a reservation
// TODO This should be extended with a random value generated by the server that is only known to the team,
// otherwise everyone with the knowledge of a team's name can end their reservation
#[derive(Deserialize)]
pub struct TeamName {
    name: String,
}

/// Starts the booking process and either returns the credentials, in case of success, or the reason why the request couldn't be fulfilled
#[post("/reservation", format = "json", data = "<data>")]
async fn reserve(data: Json<BookingData>, db: Connection<Db>) -> String {
    start_booking(data.0, db).await
    }

/// Adds a new device to the database
#[post("/add_device_to_database", format = "json", data = "<data>")]
async fn add_device(data: Json<DeviceData>, mut db: Connection<Db>) {
    let _ = add_device_to_db(data.0, &mut db).await;
}

/// Connect a device to an existing and running WireGuard interface
#[post("/add_device_to_interface", format = "json", data = "<data>")]
async fn add_device_to_interface(data: Json<DeviceInterfaceData>) {
    let _ = connect_device_to_interface(data.0).await;
}

/// Adds a new interface to the database
#[post("/add_interface", format = "json", data = "<data>")]
async fn add_interface(data: Json<InterfaceData>, mut db: Connection<Db>) {
    let _ = add_interface_to_db(data.0, &mut db).await;
}

/// Cancels an ongoing booking and frees the interface for new booking requests
#[post("/end_reservation", format = "json", data = "<data>")]
async fn end_reservation(data: Json<TeamName>, db: Connection<Db>) {
    let _ = end_booking(data.0, db).await;
}


/// Index page from which a user can log in into the website
// TODO The login system isn't utilized currently, but it could be used to
// to provide admins an option to directly configure parts of the system via webpages
// To use the login system a secret key needs to be set in the Rocket.toml
#[get("/")]
fn _index() -> Template {
    Template::render("index", context! { field: "value" })
}


#[launch]
async fn rocket() -> _ {
    rocket::build()
        .attach(Db::init())
        .attach(Template::fairing())
        .mount("/", routes![reserve, add_device, add_interface, end_reservation, add_device_to_interface])
        //.mount("/login", cred::routes())
}

